#!/usr/bin/env python3
"""
Python Package Vulnerability Scanner

A comprehensive tool to scan Python packages for vulnerabilities by:
1. Parsing requirements.txt files
2. Resolving transitive dependencies
3. Checking for CVEs and security issues
4. Generating detailed vulnerability reports
"""

import json
import subprocess
import sys
import tempfile
import os
from pathlib import Path
from typing import Dict, List, Set, Optional, Tuple
from dataclasses import dataclass
from datetime import datetime
import re
import requests


@dataclass
class Vulnerability:
    """Represents a security vulnerability"""
    id: str
    package: str
    version: str
    severity: str
    description: str
    fixed_version: Optional[str] = None
    cve_id: Optional[str] = None
    source: str = ""


@dataclass
class PackageInfo:
    """Information about a package"""
    name: str
    version: str
    is_direct: bool = True
    dependencies: List[str] = None
    
    def __post_init__(self):
        if self.dependencies is None:
            self.dependencies = []


class VulnerabilityScanner:
    """Main vulnerability scanner class"""
    
    def __init__(self, requirements_file: str = "requirements.txt"):
        self.requirements_file = Path(requirements_file)
        self.packages: Dict[str, PackageInfo] = {}
        self.vulnerabilities: List[Vulnerability] = []
        
    def parse_requirements(self) -> Dict[str, str]:
        """Parse requirements.txt file and return package:version mapping"""
        if not self.requirements_file.exists():
            raise FileNotFoundError(f"Requirements file not found: {self.requirements_file}")
        
        packages = {}
        with open(self.requirements_file, 'r') as f:
            for line in f:
                line = line.strip()
                if line and not line.startswith('#'):
                    # Handle different requirement formats
                    if '==' in line:
                        name, version = line.split('==', 1)
                        packages[name.strip()] = version.strip()
                    elif '>=' in line:
                        name = line.split('>=')[0].strip()
                        packages[name] = "latest"
                    elif '>' in line:
                        name = line.split('>')[0].strip()
                        packages[name] = "latest"
                    elif '<=' in line:
                        name = line.split('<=')[0].strip()
                        packages[name] = "latest"
                    elif '<' in line:
                        name = line.split('<')[0].strip()
                        packages[name] = "latest"
                    else:
                        # No version specified
                        packages[line.strip()] = "latest"
        
        return packages
    
    def resolve_dependencies(self, direct_packages: Dict[str, str]) -> None:
        """Resolve transitive dependencies using pip show"""
        print("Resolving dependencies...")
        
        # Add direct packages
        for name, version in direct_packages.items():
            self.packages[name] = PackageInfo(name, version, is_direct=True)
        
        # Create temporary environment to resolve dependencies
        with tempfile.TemporaryDirectory() as temp_dir:
            # Create a virtual environment
            venv_path = Path(temp_dir) / "venv"
            subprocess.run([sys.executable, "-m", "venv", str(venv_path)], 
                          capture_output=True, check=True)
            
            # Get pip path
            if os.name == 'nt':
                pip_path = venv_path / "Scripts" / "pip.exe"
            else:
                pip_path = venv_path / "bin" / "pip"
            
            # Install packages
            for name, version in direct_packages.items():
                package_spec = f"{name}=={version}" if version != "latest" else name
                try:
                    subprocess.run([str(pip_path), "install", package_spec], 
                                  capture_output=True, check=True)
                except subprocess.CalledProcessError as e:
                    print(f"Warning: Could not install {package_spec}: {e}")
            
            # Get dependency information
            result = subprocess.run([str(pip_path), "freeze"], 
                                  capture_output=True, text=True)
            
            if result.returncode == 0:
                for line in result.stdout.strip().split('\n'):
                    if '==' in line:
                        name, version = line.split('==', 1)
                        if name not in self.packages:
                            self.packages[name] = PackageInfo(name, version, is_direct=False)
    
    def check_safety_db(self) -> List[Vulnerability]:
        """Check vulnerabilities using Safety DB"""
        vulnerabilities = []
        
        try:
            # Try to use safety if available
            result = subprocess.run(['safety', 'check', '--json'], 
                                  capture_output=True, text=True)
            
            if result.returncode == 0:
                safety_data = json.loads(result.stdout)
                for vuln in safety_data:
                    vulnerabilities.append(Vulnerability(
                        id=vuln.get('id', ''),
                        package=vuln.get('package', ''),
                        version=vuln.get('installed_version', ''),
                        severity=vuln.get('severity', 'unknown'),
                        description=vuln.get('vulnerability', ''),
                        fixed_version=vuln.get('fixed_version'),
                        source='safety'
                    ))
        except FileNotFoundError:
            print("Safety not installed. Install with: pip install safety")
        except json.JSONDecodeError:
            print("Error parsing safety output")
        
        return vulnerabilities
    
    def check_pip_audit(self) -> List[Vulnerability]:
        """Check vulnerabilities using pip-audit"""
        vulnerabilities = []
        
        try:
            # Try to use pip-audit if available
            result = subprocess.run(['pip-audit', '--format=json'], 
                                  capture_output=True, text=True)
            
            if result.returncode == 0:
                audit_data = json.loads(result.stdout)
                for vuln in audit_data.get('vulnerabilities', []):
                    vulnerabilities.append(Vulnerability(
                        id=vuln.get('id', ''),
                        package=vuln.get('package', ''),
                        version=vuln.get('installed_version', ''),
                        severity=vuln.get('severity', 'unknown'),
                        description=vuln.get('description', ''),
                        fixed_version=vuln.get('fixed_version'),
                        cve_id=vuln.get('cve_id'),
                        source='pip-audit'
                    ))
        except FileNotFoundError:
            print("pip-audit not installed. Install with: pip install pip-audit")
        except json.JSONDecodeError:
            print("Error parsing pip-audit output")
        
        return vulnerabilities
    
    def check_osv_database(self) -> List[Vulnerability]:
        """Check vulnerabilities against OSV database"""
        vulnerabilities = []
        
        for package_name, package_info in self.packages.items():
            try:
                # Query OSV API
                url = "https://api.osv.dev/v1/query"
                data = {
                    "package": {
                        "name": package_name,
                        "ecosystem": "PyPI"
                    },
                    "version": package_info.version if package_info.version != "latest" else None
                }
                
                response = requests.post(url, json=data, timeout=10)
                
                if response.status_code == 200:
                    osv_data = response.json()
                    for vuln in osv_data.get('vulns', []):
                        # Extract CVE ID if available
                        cve_id = None
                        for alias in vuln.get('aliases', []):
                            if alias.startswith('CVE-'):
                                cve_id = alias
                                break
                        
                        vulnerabilities.append(Vulnerability(
                            id=vuln.get('id', ''),
                            package=package_name,
                            version=package_info.version,
                            severity=vuln.get('severity', [{}])[0].get('type', 'unknown'),
                            description=vuln.get('summary', ''),
                            cve_id=cve_id,
                            source='osv'
                        ))
            except Exception as e:
                print(f"Error checking OSV for {package_name}: {e}")
        
        return vulnerabilities
    
    def scan(self) -> None:
        """Main scan method"""
        print(f"Scanning {self.requirements_file}...")
        
        # Parse requirements
        direct_packages = self.parse_requirements()
        print(f"Found {len(direct_packages)} direct packages")
        
        # Resolve dependencies
        self.resolve_dependencies(direct_packages)
        print(f"Total packages (including dependencies): {len(self.packages)}")
        
        # Check vulnerabilities from multiple sources
        print("Checking vulnerabilities...")
        self.vulnerabilities.extend(self.check_safety_db())
        self.vulnerabilities.extend(self.check_pip_audit())
        self.vulnerabilities.extend(self.check_osv_database())
        
        # Remove duplicates
        unique_vulns = {}
        for vuln in self.vulnerabilities:
            key = f"{vuln.package}:{vuln.id}"
            if key not in unique_vulns:
                unique_vulns[key] = vuln
        
        self.vulnerabilities = list(unique_vulns.values())
    
    def generate_report(self, output_file: str = None) -> str:
        """Generate vulnerability report"""
        report = []
        report.append("="*80)
        report.append("PYTHON PACKAGE VULNERABILITY SCAN REPORT")
        report.append("="*80)
        report.append(f"Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        report.append(f"Requirements file: {self.requirements_file}")
        report.append(f"Total packages scanned: {len(self.packages)}")
        report.append(f"Direct packages: {len([p for p in self.packages.values() if p.is_direct])}")
        report.append(f"Transitive dependencies: {len([p for p in self.packages.values() if not p.is_direct])}")
        report.append(f"Total vulnerabilities found: {len(self.vulnerabilities)}")
        report.append("")
        
        if self.vulnerabilities:
            # Group by severity
            severity_counts = {}
            for vuln in self.vulnerabilities:
                severity = vuln.severity.upper()
                severity_counts[severity] = severity_counts.get(severity, 0) + 1
            
            report.append("VULNERABILITY SUMMARY BY SEVERITY:")
            for severity, count in sorted(severity_counts.items()):
                report.append(f"  {severity}: {count}")
            report.append("")
            
            # Detailed vulnerability list
            report.append("DETAILED VULNERABILITY LIST:")
            report.append("-" * 40)
            
            for vuln in sorted(self.vulnerabilities, key=lambda x: (x.package, x.severity)):
                report.append(f"Package: {vuln.package} ({vuln.version})")
                report.append(f"Vulnerability ID: {vuln.id}")
                if vuln.cve_id:
                    report.append(f"CVE ID: {vuln.cve_id}")
                report.append(f"Severity: {vuln.severity}")
                report.append(f"Source: {vuln.source}")
                report.append(f"Description: {vuln.description}")
                if vuln.fixed_version:
                    report.append(f"Fixed in version: {vuln.fixed_version}")
                report.append("")
        else:
            report.append("✓ No vulnerabilities found!")
        
        # Package list
        report.append("SCANNED PACKAGES:")
        report.append("-" * 20)
        
        direct_packages = [p for p in self.packages.values() if p.is_direct]
        transitive_packages = [p for p in self.packages.values() if not p.is_direct]
        
        if direct_packages:
            report.append("Direct packages:")
            for pkg in sorted(direct_packages, key=lambda x: x.name):
                report.append(f"  {pkg.name} ({pkg.version})")
            report.append("")
        
        if transitive_packages:
            report.append("Transitive dependencies:")
            for pkg in sorted(transitive_packages, key=lambda x: x.name):
                report.append(f"  {pkg.name} ({pkg.version})")
        
        report_text = "\n".join(report)
        
        if output_file:
            with open(output_file, 'w') as f:
                f.write(report_text)
            print(f"Report saved to: {output_file}")
        
        return report_text


def main():
    """Main function"""
    import argparse
    
    parser = argparse.ArgumentParser(description='Python Package Vulnerability Scanner')
    parser.add_argument('--requirements', '-r', default='requirements.txt',
                       help='Path to requirements.txt file')
    parser.add_argument('--output', '-o', help='Output file for report')
    parser.add_argument('--quiet', '-q', action='store_true',
                       help='Suppress output to stdout')
    
    args = parser.parse_args()
    
    scanner = VulnerabilityScanner(args.requirements)
    scanner.scan()
    
    report = scanner.generate_report(args.output)
    
    if not args.quiet:
        print(report)
    
    # Exit with error code if vulnerabilities found
    if scanner.vulnerabilities:
        sys.exit(1)


if __name__ == "__main__":
    main()